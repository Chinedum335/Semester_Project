[["index.html", "Cystopteridaceae Phylogeny Project Overview", " Cystopteridaceae Phylogeny Project Chinedum Anajemba 2023-04-30 Overview Figure 0.1: Members of the Cystopteridaceae Family Welcome to my Cystopteridaceae Phylogeny Project! The major goal of this project is to build a species-level phylogeny of the Cystopteridaceae ferns using nuclear gene loci from the most recognized species of the family. Cystopteridaceae is a family of small or medium-sized ferns that live in forests and crevices. The family contains 3 genera and about 50 species. This study aims to provide more insight into the evolutionary relationship in the Cystopteridaceae family. The content of this digital book is organized in the following Chapters: Chapter 1: Data Assembly Chapter 2: Database design and architecture Chapter 3: Phasing of Gene Copies into Polyploid Subgenomes Chapter 4: Visualizing the Phylogeny of Cystopteridaceae The codes used in this analysis are available at https://github.com/Chinedum335/Semester_Project "],["data-assembly.html", "Chapter 1 Data Assembly", " Chapter 1 Data Assembly The sequence data used in this study were assembled using PURC (Pipeline for Untangling Reticulate Complexes). Allopolyploid species are polyploid species with more than two sets of chromosomes that originate from different species. Allopolyploids present a challenge for multilocus phylogenetic inference due to their multiple distinct subgenomes, each of which may have its own evolutionary history. Generating sequence data from allopolyploid lineages is challenging due to the difficulty in isolating the sequences of each of the distinct homoeologous gene copies. Recent advances in polyploid phylogenetics have made it possible to effectively undertake phylogenetic study of groups that comprise polyploids. PURC is a pipeline for inferring the underlying biological sequences (alleles, paralogs, or homeologs) from amplicon sequencing data (PacBio, Illumina, etc), de-multiplexing them (labeling each sequence with its locus and source sample), and cleaning them (removing PCR errors, sequencing errors, and chimeras). It is geared toward analyzing polyploid species complexes but is also effective for other applications; the final output of a full PURC run includes an alignment for each locus with each homeolog or allele sequence in the amplicon data labeled with the source sample information and amount of coverage. The figure below shows the workfloe of PURC. Figure 1.1: Workflow of the Pipeline for Untangling Reticulate Complexes In this study, I used PURC to assemble the underlying sequences of four c. 1-kb-long nuclear loci from a sample of Cystopteridaceae accessions comprising 9 diploid species and 2 polyploid species.The reads of these sequences were generated using the PacBio platform. A detailed instructions on PURC installation, how to prepare input files as well as additional information for troubleshooting can be found in the README file in the PURC repository "],["database-design.html", "Chapter 2 Database design and architecture 2.1 Building the Database", " Chapter 2 Database design and architecture In this chapter, we will build a relational database that will translate real-world relationships between our data entities into structural relationships between our data tables. Let’s take a look at the content and structure of the database: Figure 2.1: Diagram of the cystpteridaceae database The database is composed of 2 tables- the sample_Info and the phasing_stat table. The sample_info table includes individual information on the taxonomy, ploidy level and source of each species that are used in this project. The phasing statistics table provides the statistics for each sample (i.e. species) used in this project. Primary keys are in italics and foreign keys are in bold. The goFlagID is a unique number assigned to each species/sample and it is the foreign key that connects both tables 2.1 Building the Database This database will be built with RSQLite, which is an R package that provides an interface with SQLite such that you can interact with the database from within R. RSQLite relies on another R package called DBI (which stands for database interface). DBI is a package that provides generic functions for interfacing databases with R, and RSQLite makes adjustments that are specific to SQLite. The first thing, we are going to do is to load the DBI package: library(DBI) 2.1.1 Establising a database connection The next step is to connect or rather create a new database and the dbConnect function performs this task. my_db &lt;- dbConnect(RSQLite::SQLite(), &quot;my_db.db&quot;) 2.1.2 Creating the sample_info table in the database To create, import, and plug the sample_info table in the database. Use the code below: # The line below creates the sample_info table in the database # dbExecute(my_db, &quot;CREATE TABLE sample_info ( goFlagID varchar(20) NOT NULL, species_name varchar(30), species_family char(20), ploidy varchar(3), species_abbreviation varchar(10), provenance varchar(45), collector varchar(20), database_ID varchar(30), voucher_ID varchar(30), PRIMARY KEY (goFlagID) );&quot;) # The line below imports the sample_info data # sample_info &lt;- read.csv(&quot;sample_info.csv&quot;, stringsAsFactors = FALSE) # The line below plugs the sample_info data into table # dbWriteTable(my_db, &quot;sample_info&quot;, sample_info, append = TRUE) # The line below sends queries to the database # dbGetQuery(my_db, &quot;SELECT * FROM sample_info LIMIT 10;&quot;) 2.1.3 Creating the Phasing_stats_table in the database To create, import, and plug the Phasing_stats table in the database. Use the code below: # The line below creates the Phasing_stats table in the database # dbExecute(my_db, &quot;CREATE TABLE Phasing_stats_table ( species_abbreviation varchar(10) NOT NULL PRIMARY KEY, goFlagID varchar(20) NOT NULL, no_of_loci INTEGER, no_var_loc INTEGER, no_nonvar_loc INTEGER, no_phased_loci INTEGER, avg_length float, avg_nonvar float, avg_het float, FOREIGN KEY (goFlagID) REFERENCES sample_info(goFlagID) );&quot;) # The line below imports the Phasing_stat data # Phasing_stat_table &lt;- read.csv(&quot;Phasing_stat_table.csv&quot;, stringsAsFactors = FALSE) # The line below plugs the Phasing_stat data into table # dbWriteTable(my_db, &quot;Phasing_stat_table&quot;, Phasing_stat_table, append = TRUE) # The line below sends queries to the database # dbGetQuery(my_db, &quot;SELECT * FROM Phasing_stat_table LIMIT 10;&quot;) "],["phasing-design.html", "Chapter 3 Phasing of Gene Copies into Polyploid Subgenomes", " Chapter 3 Phasing of Gene Copies into Polyploid Subgenomes One of the main challenges to reconstructing a multi-locus phylogeny of clades with allopolyploid species is the phasing of gene copies into polyploid subgenomes. Allopolyploids contain distinct subgenomes each with their own evolutionary history. When sequencing loci from such organisms, unique copies of each locus may be recovered from each subgenome and if each copy of each locus is not assigned to the correct subgenome,then multilocus phylogenetic inference can be erroneous and will lead to unsound results. homologizer is a Bayesian method that uses a phylogenetic framework to phase gene copies (i.e. assign sequence to the correct subgenome) across loci. In this chapter, we will discuss how to use homologizer to phase gene copies into polyploid subgenomes. homologizer is implemented in the open-source phylogenetic inference software RevBayes. RevBayes is a rich and complex phylogenetic inference tool that can accommodate a vast array of models. The RevBayes language is similar to the language used in R and it is designed to support interactive analysis. Extensive tutorials for Revbayes including how to download the software are available here In a homologizer analysis, phylogenies containing allopolyploid organisms are represented as multilabeled trees (“mul-trees”), where each hybrid accession is present multiple times, once for each subgenome (each distinct evolutionary history). The data used in this study consist of four single-copy nuclear loci (APP, GAP, IBR, and PGI) for a sample of 9 diploids and 2 tetraploids generated using PURC pipeline (see Chapter 1). A detailed instruction on how to prepare input file and run homologizer analysis can be found at homologizer repository. The script used for this analysis, cystopteridaceae_homologizer can be found here. This script can be run within Revbayes by typing source(cystopteridaceae_homologizer) from the 5_Code directory. The code in cystopteridaceae_homologizerscript is shown below: # This code Specifies a homologizer model that jointly infer the phase and phylogeny. # Run an MCMC analysis by default. Set bayes_factors = TRUE to calculate # the marginal likelihood with a stepping stone analysis. # # Will Freyman # bayes_factors = FALSE output_file = &quot;../4_Output_Trees/homologizer_output&quot; # input sequence alignments alignments = [&quot;../2_Processed_Data/APP.nex&quot;, &quot;../2_Processed_Data/GAP.nex&quot;, &quot;../2_Processed_Data/IBR.nex&quot;, &quot;../2_Processed_Data/PGI.nex&quot;] num_loci = alignments.size() for (i in 1:num_loci) { data[i] = readDiscreteCharacterData(alignments[i]) } # add blank second IBR gene copy for C_tasmanica_6379 data[3].addMissingTaxa(&quot;6379_copy2&quot;) # set initial phase for (i in 1:num_loci) { data[i].setHomeologPhase(&quot;6379_copy1&quot;, &quot;C_tasmanica_6379_A&quot;) data[i].setHomeologPhase(&quot;6379_copy2&quot;, &quot;C_tasmanica_6379_B&quot;) data[i].setHomeologPhase(&quot;7974_copy1&quot;, &quot;xCystocarpium_7974_A&quot;) data[i].setHomeologPhase(&quot;7974_copy2&quot;, &quot;xCystocarpium_7974_B&quot;) data[i].setHomeologPhase(&quot;7974_copy3&quot;, &quot;xCystocarpium_7974_C&quot;) data[i].setHomeologPhase(&quot;7974_copy4&quot;, &quot;xCystocarpium_7974_D&quot;) # for the 3-tip phasing model uncomment these lines: #data[i].addMissingTaxa(&quot;6379_BLANK3&quot;) #data[i].setHomeologPhase(&quot;6379_BLANK3&quot;, &quot;C_tasmanica_6379_C&quot;) } # add missing taxa for (i in 1:num_loci) { for (j in 1:num_loci) { data[i].addMissingTaxa(data[j].taxa()) } } num_tips = data[1].ntaxa() n_branches = 2 * num_tips - 3 # set up branches mvi = 0 for (i in 1:n_branches) { branch_lengths[i] ~ dnExponential(100) moves[++mvi] = mvScale(branch_lengths[i], weight=1.0) } # set up tree topology topology ~ dnUniformTopology(data[1].taxa()) moves[++mvi] = mvNNI(topology, weight=40.0) moves[++mvi] = mvSPR(topology, weight=40.0) # combine branches and topology into tree tree := treeAssembly(topology, branch_lengths) # substitution models for (i in 1:num_loci) { # gtr for each locus er_prior &lt;- v(1,1,1,1,1,1) er[i] ~ dnDirichlet(er_prior) er[i].setValue(simplex(v(1,1,1,1,1,1))) moves[++mvi] = mvSimplexElementScale(er[i], weight=5) pi_prior &lt;- v(1,1,1,1) pi[i] ~ dnDirichlet(pi_prior) pi[i].setValue(simplex(v(1,1,1,1))) moves[++mvi] = mvSimplexElementScale(pi[i], weight=5) Q[i] := fnGTR(er[i], pi[i]) if (i == 1) { rate_multiplier[i] &lt;- 1.0 } else { rate_multiplier[i] ~ dnExponential(1) moves[++mvi] = mvScale(rate_multiplier[i], weight=5) } } # phylogenetic CTMC distributions for each locus for (i in 1:num_loci) { ctmc[i] ~ dnPhyloCTMC(tree=tree, Q=Q[i], branchRates=rate_multiplier[i], type=&quot;DNA&quot;) ctmc[i].clamp(data[i]) } # make phasing proposals for (i in 1:4) { moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;C_tasmanica_6379_A&quot;, &quot;C_tasmanica_6379_B&quot;, weight=2) moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;xCystocarpium_7974_A&quot;, &quot;xCystocarpium_7974_B&quot;, weight=2) moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;xCystocarpium_7974_A&quot;, &quot;xCystocarpium_7974_C&quot;, weight=2) moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;xCystocarpium_7974_A&quot;, &quot;xCystocarpium_7974_D&quot;, weight=2) moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;xCystocarpium_7974_B&quot;, &quot;xCystocarpium_7974_C&quot;, weight=2) moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;xCystocarpium_7974_B&quot;, &quot;xCystocarpium_7974_D&quot;, weight=2) moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;xCystocarpium_7974_C&quot;, &quot;xCystocarpium_7974_D&quot;, weight=2) # for the 3-tip phasing model uncomment these lines: #moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;C_tasmanica_6379_A&quot;, &quot;C_tasmanica_6379_B&quot;, weight=2) #moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;C_tasmanica_6379_A&quot;, &quot;C_tasmanica_6379_C&quot;, weight=2) #moves[++mvi] = mvHomeologPhase(ctmc[i], &quot;C_tasmanica_6379_B&quot;, &quot;C_tasmanica_6379_C&quot;, weight=2) } mymodel = model(Q) # set up monitors mni = 0 monitors[++mni] = mnModel(filename=output_file + &quot;.log&quot;, printgen=1) monitors[++mni] = mnFile(filename=output_file + &quot;.trees&quot;, printgen=1, tree) monitors[++mni] = mnScreen(printgen=1) for (i in 1:num_loci){ monitors[++mni] = mnHomeologPhase(filename=output_file + &quot;_locus_&quot; + i + &quot;_phase.log&quot;, printgen=1, ctmc[i]) } if (bayes_factors) { # running stepping stone analysis pow_p = powerPosterior(mymodel, moves, monitors, output_file + &quot;.out&quot;, cats=50, sampleFreq=1) pow_p.burnin(generations=200, tuningInterval=50) #pow_p.run(generations=2000) pow_p.run(generations=1000) ss = steppingStoneSampler(file=output_file + &quot;.out&quot;, powerColumnName=&quot;power&quot;, likelihoodColumnName=&quot;likelihood&quot;) # print the marginal likelihood to screen print(ss.marginal()) } else { # run MCMC mymcmc = mcmc(mymodel, monitors, moves) #mymcmc.run(generations=10000) mymcmc.run(generations=2000) # summarize results treetrace = readTreeTrace(output_file + &quot;.trees&quot;, treetype=&quot;non-clock&quot;, burnin=0.25) map_tree = mapTree(treetrace, output_file + &quot;_map.tree&quot;) mcc_tree = mccTree(treetrace, output_file + &quot;_mcc.tree&quot;) } When the analysis is complete, a homologizer_output folder that contains all of the files specified with the monitors will be created in the specified output folder "],["phylogeny-design.html", "Chapter 4 Visualizing the Phylogeny of Cystopteridaceae 4.1 Summarizing the Results of homologizer Analysis 4.2 Summarizing homologizer Phasing Estimates and Plotting it in R", " Chapter 4 Visualizing the Phylogeny of Cystopteridaceae This chapter provides a detailed assessment of the results obtained following homologizerrun. 4.1 Summarizing the Results of homologizer Analysis In any Bayesian phylogenetic analysis, It is always important to carefully assess the MCMC samples for the various parameters in your analysis. Some of the assessment that can be done include: 4.1.1 Convergence Assessment Convergence of an MCMC analysis is crucial to assure that the chain has sampled from the stationary distribution and that we have sufficiently many samples to approximate the posterior distribution. That is, the MCMC has explored the parameter space long enough to reach the true posterior distribution of the parameters and the values we are sampling belong to that distribution. Theory says that a chain that runs through an infinite time, will reach convergence. An example of how to plot trace in R is seen below. The caterpillar-like look is a good sign, it shows that our run reached convergence and the MCMC run appears to converge after approximately 100 iterations. The code chunk for plotting trace can be found below. Let’s load in all the packages that are required for all our assessments before running the code. # Loading required packages library(RevGadgets) library(coda) library(ggplot2) library(ggtree) library(grid) library(gridExtra) library(tidyverse) library(plyr) library(magrittr) library(tidyr) library(dplyr) library(ape) # specify the input file files &lt;- &quot;../4_Output_Trees/homologizer_output/homologizer.log&quot; # read the trace and discard burnin trace_quant &lt;- readTrace(path = files, burnin = 0.1) # assess convergence with coda trace_quant_MCMC &lt;- as.mcmc(trace_quant[[1]]) effectiveSize(trace_quant_MCMC) traceplot(trace_quant_MCMC, col = 3, smooth = T) Figure 4.1: MCMC trace from the Cystopteridaceae homologizer analysis 4.1.2 Summarizing and Visiualizing Traces of Specific Parameter The next assessment is to summarize the traces of specific parameters. In order to accomplish this, we will use the SummarizeTrace() function implemented in RevGadgets to calculate the mean and 95% credible interval for the quantitative variables. In this study, we estimated a substitution rate multiplier for each of the alignments except the first one and drew the rate multipliers from an exponential distribution. To examine the rate_multiplier parameter values in our trace file, we summarize their distributions using this code below: summarizeTrace(trace = trace_quant, vars = c(&quot;rate_multiplier[2]&quot;,&quot;rate_multiplier[3]&quot;,&quot;rate_multiplier[4]&quot;)) ## $`rate_multiplier[2]` ## $`rate_multiplier[2]`$trace_1 ## mean median MAP quantile_2.5 quantile_97.5 ## 1.601059 1.596110 1.617056 1.308977 1.972417 ## ## ## $`rate_multiplier[3]` ## $`rate_multiplier[3]`$trace_1 ## mean median MAP quantile_2.5 quantile_97.5 ## 0.7831243 0.7744505 0.7579271 0.6115875 0.9833560 ## ## ## $`rate_multiplier[4]` ## $`rate_multiplier[4]`$trace_1 ## mean median MAP quantile_2.5 quantile_97.5 ## 1.239250 1.237225 1.232322 1.017644 1.488608 Then to plot these distributions, we will use the plotTrace() function to produces a list of ggplot2 objects, with multiple plots of multiple runs in the trace object. plotTrace(trace = trace_quant, vars = c(&quot;rate_multiplier[2]&quot;,&quot;rate_multiplier[3]&quot;,&quot;rate_multiplier[4]&quot;))[[1]] ## Using as id variables Figure 4.2: The posterior densities of the nucleotide rate multipliers under a GTR substitution model. Colored areas under the curve correspond to the 95% credible interval. 4.2 Summarizing homologizer Phasing Estimates and Plotting it in R homologizer run ends with the creation of a tree file homologizer_output/homologizer_map.tree that can be plotted and rooted in software like FigTree or APE. However, these software (Figtree or Ape) can’t be used to clearly summarize the phasing estimates of homologizer run. R has features that could be used to achieve this task. The chunk of R code below summarizes and plots the phasing estimates following homologizer run. This code can be found here genecopyFn=&#39;../1_Raw_Data/cystopteridaceae_genomes.csv&#39; tree_file = &#39;../4_Output_Trees/homologizer_output/homologizer_map_rooted.trees&#39; input_dir = &#39;../4_Output_Trees/homologizer_output/&#39; output_dir = &#39;../4_Output_Trees/homologizer_output/&#39; prefix = &#39;../4_Output_Trees/homologizer_output/homologizer&#39; # Required packages #library(ggplot2) #library(plyr) #library(magrittr) #library(tidyr) #library(dplyr) #library(ggtree) #library(ape) genecopymap = read.csv(genecopyFn,header=T,stringsAsFactors=TRUE) samples = split(genecopymap$Subgenome,genecopymap$Sample) # names of the loci in the log file loci = names(genecopymap)[3:length(genecopymap)] # what percentage of MCMC samples to exclude? burnin = 0.1 # modified from ggtree gheatmap homologized = function (p, data, data_labels, offset = 0, width = 1, low = &quot;green&quot;, mid, high = &quot;red&quot;, color = &quot;white&quot;, colnames = TRUE, colnames_position = &quot;bottom&quot;, colnames_angle = 0, colnames_level = NULL, colnames_offset_x = 0, colnames_offset_y = 0, font.size = 4, family = &quot;&quot;, hjust = 0.5, legend_title = &quot;value&quot;) { colnames_position %&lt;&gt;% match.arg(c(&quot;bottom&quot;, &quot;top&quot;)) variable &lt;- value &lt;- lab &lt;- y &lt;- NULL width &lt;- width * (p$data$x %&gt;% range(na.rm = TRUE) %&gt;% diff)/ncol(data) isTip &lt;- x &lt;- y &lt;- variable &lt;- value &lt;- from &lt;- to &lt;- NULL df &lt;- p$data nodeCo &lt;- intersect(df %&gt;% filter(is.na(x)) %&gt;% select(.data$parent, .data$node) %&gt;% unlist(), df %&gt;% filter(!is.na(x)) %&gt;% select(.data$parent, .data$node) %&gt;% unlist()) labCo &lt;- df %&gt;% filter(.data$node %in% nodeCo) %&gt;% select(.data$label) %&gt;% unlist() selCo &lt;- intersect(labCo, rownames(data)) isSel &lt;- df$label %in% selCo df &lt;- df[df$isTip | isSel, ] start &lt;- max(df$x, na.rm = TRUE) + offset dd &lt;- as.data.frame(data) dd2 &lt;- as.data.frame(data_labels) i &lt;- order(df$y) i &lt;- i[!is.na(df$y[i])] lab &lt;- df$label[i] dd &lt;- dd[match(lab, rownames(dd)), , drop = FALSE] dd2 &lt;- dd2[match(lab, rownames(dd2)), , drop = FALSE] dd$y &lt;- sort(df$y) dd2$y &lt;- sort(df$y) dd$lab &lt;- lab dd2$lab &lt;- lab dd &lt;- gather(dd, variable, value, -c(lab, y)) dd2 &lt;- gather(dd2, variable, value, -c(lab, y)) i &lt;- which(dd$value == &quot;&quot;) if (length(i) &gt; 0) { dd$value[i] &lt;- NA dd2$value[i] &lt;- NA } if (is.null(colnames_level)) { dd$variable &lt;- factor(dd$variable, levels = colnames(data)) } else { dd$variable &lt;- factor(dd$variable, levels = colnames_level) } V2 &lt;- start + as.numeric(dd$variable) * width mapping &lt;- data.frame(from = dd$variable, to = V2) mapping &lt;- unique(mapping) dd$x &lt;- V2 dd2$x &lt;- V2 dd$width &lt;- width dd2$width &lt;- width dd[[&quot;.panel&quot;]] &lt;- factor(&quot;Tree&quot;) dd2[[&quot;.panel&quot;]] &lt;- factor(&quot;Tree&quot;) if (is.null(color)) { p2 &lt;- p + geom_tile(data = dd, aes(x, y, fill = value), width = width, inherit.aes = FALSE) } else { p2 &lt;- p + geom_tile(data = dd, aes(x, y, fill = value), width = width, color = color, inherit.aes = FALSE) p2 &lt;- p2 + geom_text(data = dd2, aes(x, y, label=value), size=1, inherit.aes = FALSE) # TODO #print(dd) dd3 = data.frame() start_x = max(dd$x) height = max(dd$y) margin = 0.006 for (y in unique(dd$y)) { pp = mean(dd[dd$y == y, &#39;value&#39;], na.rm=TRUE) dd4 = data.frame(pp = pp, x = pp/200 + margin + start_x, y=y) dd3 = rbind(dd3, dd4) } #print(dd3) p2 &lt;- p2 + geom_segment(aes(x=start_x+margin, xend=1/200 + start_x + margin, y=0.2, yend=0.2), size=0.5, inherit.aes = FALSE) p2 &lt;- p2 + geom_segment(aes(x=1/200+start_x+margin, xend=1/200+start_x+margin, y=0.5, yend=height), color=&#39;grey85&#39;, linetype=&#39;dotted&#39;, size=0.35, inherit.aes = FALSE) p2 &lt;- p2 + geom_segment(aes(x=start_x+margin, xend=start_x+margin, y=0.5, yend=height), color=&#39;grey85&#39;, linetype=&#39;dotted&#39;, size=0.35, inherit.aes = FALSE) p2 &lt;- p2 + geom_point(data = dd3, aes(x, y, color=pp), size=1.25, inherit.aes = FALSE, show.legend=FALSE) p2 &lt;- p2 + geom_text(label=&#39;0.0&#39;, x=start_x+margin, y=-0.2, size=1.25, color=&#39;grey50&#39;) p2 &lt;- p2 + geom_text(label=&#39;1.0&#39;, x=start_x+margin+1/200, y=-0.2, size=1.25, color=&#39;grey50&#39;) } if (methods::is(dd$value, &quot;numeric&quot;)) { midpoint = max(dd$value, na.rm=TRUE) - min(dd$value, na.rm=TRUE) midpoint = midpoint/2 + min(dd$value, na.rm=TRUE) midpoint = 0.25 p2 &lt;- p2 + scale_fill_gradient2(low = low, mid=mid, high = high, midpoint=midpoint, na.value = &quot;white&quot;, name = legend_title, limits=c(0,1)) p2 &lt;- p2 + scale_color_gradient2(low = low, mid=mid, high = high, midpoint=midpoint, na.value = &quot;white&quot;, name = legend_title, limits=c(0,1)) #na.value = NA, name = legend_title) } else { p2 &lt;- p2 + scale_fill_discrete(na.value = NA, name = legend_title) } if (colnames) { if (colnames_position == &quot;bottom&quot;) { y &lt;- 0 } else { y &lt;- max(p$data$y) + 1 } mapping$y &lt;- y mapping[[&quot;.panel&quot;]] &lt;- factor(&quot;Tree&quot;) p2 &lt;- p2 + geom_text(data = mapping, aes(x = to, y = y, label = from), size = font.size, family = family, inherit.aes = FALSE, angle = colnames_angle, nudge_x = colnames_offset_x, nudge_y = colnames_offset_y, hjust = hjust) } p2 &lt;- p2 + theme(legend.position = &quot;right&quot;) if (!colnames) { p2 &lt;- p2 + scale_y_continuous(expand = c(0, 0)) } attr(p2, &quot;mapping&quot;) &lt;- mapping return(p2) } # polyploid samples and their tips # samples = list(&#39;A_taiwaniana_6137&#39; = c(&quot;A_taiwaniana_6137_A&quot;, &quot;A_taiwaniana_6137_B&quot;), # &#39;A_tenuisecta_sp2_8704&#39; = c(&quot;A_tenuisecta_sp2_8704_A&quot;, &quot;A_tenuisecta_sp2_8704_B&quot;), # &#39;A_tenuisecta_sp3_8745&#39; = c(&quot;A_tenuisecta_sp3_8745_A&quot;, &quot;A_tenuisecta_sp3_8745_B&quot;), # &#39;C_diaphana_6380&#39; = c(&quot;C_diaphana_6380_A&quot;, &quot;C_diaphana_6380_B&quot;), # &#39;C_fragilis_sp1_7009&#39; = c(&quot;C_fragilis_sp1_7009_A&quot;, &quot;C_fragilis_sp1_7009_B&quot;), # &#39;C_fragilis_sp2_7248&#39; = c(&quot;C_fragilis_sp2_7248_A&quot;, &quot;C_fragilis_sp2_7248_B&quot;), # &#39;C_montana_7943&#39; = c(&quot;C_montana_7943_A&quot;, &quot;C_montana_7943_B&quot;), # &#39;C_pellucida_6055&#39; = c(&quot;C_pellucida_6055_A&quot;, &quot;C_pellucida_6055_B&quot;), # &#39;C_sudetica_8674&#39; = c(&quot;C_sudetica_8674_A&quot;, &quot;C_sudetica_8674_B&quot;), # &#39;C_tasmanica_6379&#39; = c(&quot;C_tasmanica_6379_A&quot;, &quot;C_tasmanica_6379_B&quot;), # &#39;C_tenuis_6387&#39; = c(&quot;C_tenuis_6387_A&quot;, &quot;C_tenuis_6387_B&quot;), # &#39;C_utahensis_6848&#39; = c(&quot;C_utahensis_6848_A&quot;, &quot;C_utahensis_6848_B&quot;), # &#39;G_continentale_6979&#39; = c(&quot;G_continentale_6979_A&quot;, &quot;G_continentale_6979_B&quot;), # &#39;G_disjunctum_7751&#39; = c(&quot;G_disjunctum_7751_A&quot;, &quot;G_disjunctum_7751_B&quot;), # &#39;G_oyamense_sp2_8739&#39; = c(&quot;G_oyamense_sp2_8739_A&quot;, &quot;G_oyamense_sp2_8739_B&quot;), # &#39;G_remotepinnatum_4862&#39; = c(&quot;G_remotepinnatum_4862_A&quot;, &quot;G_remotepinnatum_4862_B&quot;), # &#39;G_robertianum_7945&#39; = c(&quot;G_robertianum_7945_A&quot;, &quot;G_robertianum_7945_B&quot;), # &#39;G_dryopteris_7981&#39; = c(&quot;G_dryopteris_7981_A&quot;, &quot;G_dryopteris_7981_B&quot;, &quot;G_dryopteris_7981_C&quot;, &quot;G_dryopteris_7981_D&quot;), # &#39;xCystocarpium_7974&#39; = c(&quot;xCystocarpium_7974_A&quot;, &quot;xCystocarpium_7974_B&quot;, &quot;xCystocarpium_7974_C&quot;,&quot;xCystocarpium_7974_D&quot;)) # populate empty dataframes to hold results map_prob_results = data.frame() joint_map_phase_results = data.frame() for (sample in names(samples)) { sample_joint_map_prob = data.frame() sample_joint_map_phase = data.frame() for (i in 1:length(loci)) { sample_joint_map_prob[1, loci[i]] = 0.0 sample_joint_map_phase[1, loci[i]] = &#39;&#39; row.names(sample_joint_map_prob) = c(sample) row.names(sample_joint_map_phase) = c(sample) } map_prob_results = rbind(map_prob_results, sample_joint_map_prob) joint_map_phase_results = rbind(joint_map_phase_results, sample_joint_map_phase) } # for each sample loop over each locus marginal_results = data.frame() for (sample in names(samples)) { joint_results = data.frame() for (i in 1:length(loci)) { # read in file and exclude burnin f_in = paste0(prefix, &#39;_locus_&#39;,i, &#39;_phase.log&#39;) d = read.csv(f_in, sep=&#39;\\t&#39;,stringsAsFactors = TRUE,row.names=1) d = d[floor(nrow(d)*burnin):nrow(d),] # get joint phase assignments for this locus d1 = d[, samples[[sample]]] joint_results_locus = as.data.frame(table(d1)) joint_results_locus$joint_prob = joint_results_locus$Freq / sum(joint_results_locus$Freq) joint_results_locus$locus = loci[i] joint_results = rbind(joint_results, joint_results_locus) # get the MAP joint phase for the plot map = which(joint_results_locus[&#39;joint_prob&#39;] == max(joint_results_locus[&#39;joint_prob&#39;]))[1] for (tip in samples[[sample]]) { #map_prob_results[tip,loci[i]] = joint_results_locus[map, &#39;joint_prob&#39;] joint_map_phase_results[tip,loci[i]] = as.character(joint_results_locus[map, tip]) } # get marginal posterior probs for (tip in samples[[sample]]) { m = as.data.frame(table(d[tip])) m$marginal_prob = m$Freq / sum(m$Freq) # m$phase = m$Var1 m$phase = m[,1] # is Var1 supposed to be the first column? trying this m = within(m, rm(Freq)) # m = within(m, rm(Var1)) m[,1] = NULL # is Var1 supposed to be the first column? trying this m$locus = loci[i] m$tip_name = tip marginal_results = rbind(marginal_results, m) } } joint_results = within(joint_results, rm(Freq)) #out_file = paste0(prefix, &#39;_joint_phase_probs_&#39;, sample, &#39;.csv&#39;) #write.csv(joint_results, out_file, row.names=FALSE) } #out_file = paste0(prefix, &#39;_marginal_phase_probs.csv&#39;) #write.csv(marginal_results, out_file, row.names=FALSE) # get marginal probs for the joint MAP phase for (sample in names(samples)) { for (tip in samples[[sample]]) { for (i in 1:length(loci)) { m = marginal_results[marginal_results$phase == joint_map_phase_results[tip,loci[i]] &amp; marginal_results$locus == loci[i] &amp; marginal_results$tip == tip, &#39;marginal_prob&#39;] map_prob_results[tip,loci[i]] = m } } } tree = treeio::read.beast(tree_file) #tree@phylo = drop.tip(tree@phylo, &#39;6379_BLANK2&#39;) p = ggtree(tree) p = p + geom_tiplab(size=2, align=T, linesize=0.25, offset=0.0005) p = homologized(p, map_prob_results, joint_map_phase_results, offset=0.018, low=&quot;#EE0000&quot;, mid=&quot;#FF0099&quot;, high=&quot;#DDDDFF&quot;, colnames_position=&quot;top&quot;, font.size=2, width=0.5, legend_title=&quot;Posterior\\nProbability&quot;) p = p + theme(legend.text=element_text(size=6), legend.title=element_text(size=8)) p Figure 4.3: Inferred phasing of gene copies into subgenomes summarized on the MAP phylogeny for the Cystopteridaceae dataset # Saving the output file ggsave(&#39;../Figures/homologized_joint_MAP.pdf&#39;, height=3, width=7) The phase is estimated for the two polyploid accessions xCystocarpium_7974 and C_tasmanica_6379. To the right of the tree, each column represents a locus, and the joint MAP phase assignment is shown as text within each box. Each box is colored by the marginal posterior probability of the phase assignment. These marginal posterior probabilities are useful to quantify the uncertainty within the joint MAP phasing assignment. For example, it may be that the joint MAP phase of a given polyploid has a low marginal posterior probability in some subgenomes but a high marginal posterior probability in other subgenomes. Adjacent to the heatmap is a column that shows the mean marginal probability across loci of the phasing assignment per tip, which summarizes the model’s overall confidence in the phasing of that tip. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
